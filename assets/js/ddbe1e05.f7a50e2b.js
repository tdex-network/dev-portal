"use strict";(self.webpackChunkdev_portal=self.webpackChunkdev_portal||[]).push([[4651],{984:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>s,default:()=>v,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var n=t(8168),i=(t(6540),t(5680));const o={title:"Discovery",sidebar_position:5},s=void 0,a={unversionedId:"trader/SDK/Javascript/discovery",id:"version-0.9.1/trader/SDK/Javascript/discovery",title:"Discovery",description:"TDEX clients often use multiple daemons. These daemons can provide the same market to the trader client. In this case, it is up to the trader to choose the provider that best suits his needs. For instance if two daemons provides a market LBTCUSDT, the trader might want to choose the daemon that offers him the lowest price for instance.",source:"@site/versioned_docs/version-0.9.1/trader/SDK/Javascript/discovery.md",sourceDirName:"trader/SDK/Javascript",slug:"/trader/SDK/Javascript/discovery",permalink:"/docs/v0/trader/SDK/Javascript/discovery",draft:!1,editUrl:"https://github.com/tdex-network/dev-portal/edit/master/versioned_docs/version-0.9.1/trader/SDK/Javascript/discovery.md",tags:[],version:"0.9.1",sidebarPosition:5,frontMatter:{title:"Discovery",sidebar_position:5},sidebar:"version-0.9.1/tutorialSidebar",previous:{title:"Swap",permalink:"/docs/v0/trader/SDK/Javascript/swap"},next:{title:"Overview",permalink:"/docs/v0/provider/intro"}},c={},l=[{value:"Best balance discovery",id:"best-balance-discovery",level:3},{value:"Best price discovery",id:"best-price-discovery",level:3},{value:"Combine <code>Discovery</code>",id:"combine-discovery",level:3}],d={toc:l},p="wrapper";function v(e){let{components:r,...t}=e;return(0,i.yg)(p,(0,n.A)({},d,t,{components:r,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"TDEX clients often use multiple daemons. These daemons can provide the same market to the trader client. In this case, it is up to the trader to choose the provider that best suits his needs. For instance if two daemons provides a market LBTC<->USDT, the trader might want to choose the daemon that offers him the lowest price for instance."),(0,i.yg)("p",null,"For this kind of use case, the SDK provides a class named ",(0,i.yg)("inlineCode",{parentName:"p"},"Discoverer"),'. It allows to "discover" the best daemon (among a list) according to a given strategy. The "strategy" using to select daemons is called ',(0,i.yg)("inlineCode",{parentName:"p"},"Discovery"),". It is basically a function with the following signature: "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-typescript"},"export type Discovery = (\n  clients: TraderClientInterface[], // 1 client = 1 provider\n  discoveryOpts: DiscoveryOpts, // data about the trade\n  errorHandler?: (err: any) => Promise<void> // optional async error handler, if `undefined` errors will be ignored\n) => Promise<TraderClientInterface[]>;\n\nexport interface DiscoveryOpts {\n  market: MarketInterface; // which market the trader is targetting\n  amount: number; // using for preview\n  asset: string; // using for preview\n  type: TradeType; // type of trade BUY or SELL\n}\n")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"Discoverer")," takes ",(0,i.yg)("inlineCode",{parentName:"p"},"Discovery")," function in constructor. the SDK exports two discovery functions: ",(0,i.yg)("inlineCode",{parentName:"p"},"bestBalanceDiscovery")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"bestPriceDiscovery"),". However, feel free to write your own according to your needs."),(0,i.yg)("h3",{id:"best-balance-discovery"},"Best balance discovery"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"bestBalanceDiscovery")," will make gRPC calls on ",(0,i.yg)("inlineCode",{parentName:"p"},"balances")," endpoints for each providers. Then, it compares all the balances and return the one with the greater amount. In other words, it allows you to select the provider that has the most liquidity for the targeted market. "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-typescript"},'import { Discoverer, bestBalanceDiscovery } from "tdex-sdk";\n\nconst myProvidersClients: TraderClientInterface[] = [...]\n\nconst discoverer = new Discoverer(\n  myProvidersClients,\n  bestBalanceDiscovery,\n);\n\nconst discoveryOpts = ... // discoveryOpts describes the trade\nconst bestBalanceProviderClient = (await discoverer.discover(discoveryOpts))[0];\n// make your trade on the daemon with the greatest liquidity\n')),(0,i.yg)("h3",{id:"best-price-discovery"},"Best price discovery"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"bestPriceDiscovery")," will make gRPC calls on ",(0,i.yg)("inlineCode",{parentName:"p"},"marketPrice")," endpoints for each providers. Then, it compares all the prices and return the client with the lowest price."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-typescript"},'import { Discoverer, bestPriceDiscovery } from "tdex-sdk";\n\nconst myProvidersClients: TraderClientInterface[] = [...]\n\nconst discoverer = new Discoverer(\n  myProvidersClients, \n  bestPriceDiscovery,\n);\n\nconst discoveryOpts = ... // discoveryOpts describes the trade\nconst bestPriceProviderClient = (await discoverer.discover(discoveryOpts))[0];\n// make your trade on the daemon with the lowest price\n')),(0,i.yg)("h3",{id:"combine-discovery"},"Combine ",(0,i.yg)("inlineCode",{parentName:"h3"},"Discovery")),(0,i.yg)("p",null,"The Javascript SDK provides also an utility function using to combine several ",(0,i.yg)("inlineCode",{parentName:"p"},"Discovery")," functions."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-typescript"},'import { combineDiscovery, bestPriceDiscovery, bestBalanceDiscovery } from "tdex-sdk";\n\nconst lowestPriceThenGreatestBalance = combineDiscovery(bestPriceDiscovery, bestBalanceDiscovery);\n// this discovery function will firt look at the lowest price for each providers (bestPriceDiscovery)\n// then, if there is several providers providing the lowest price, the function will use bestBalanceDiscovery to select the provider.\n\nconst discoverer = new Discoverer(\n  myProvidersClients, \n  lowestPriceThenGreatestBalance,\n);\n')))}v.isMDXComponent=!0},5680:(e,r,t)=>{t.d(r,{xA:()=>d,yg:()=>m});var n=t(6540);function i(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function o(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?o(Object(t),!0).forEach((function(r){i(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function a(e,r){if(null==e)return{};var t,n,i=function(e,r){if(null==e)return{};var t,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],r.indexOf(t)>=0||(i[t]=e[t]);return i}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=n.createContext({}),l=function(e){var r=n.useContext(c),t=r;return e&&(t="function"==typeof e?e(r):s(s({},r),e)),t},d=function(e){var r=l(e.components);return n.createElement(c.Provider,{value:r},e.children)},p="mdxType",v={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},y=n.forwardRef((function(e,r){var t=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,d=a(e,["components","mdxType","originalType","parentName"]),p=l(t),y=i,m=p["".concat(c,".").concat(y)]||p[y]||v[y]||o;return t?n.createElement(m,s(s({ref:r},d),{},{components:t})):n.createElement(m,s({ref:r},d))}));function m(e,r){var t=arguments,i=r&&r.mdxType;if("string"==typeof e||i){var o=t.length,s=new Array(o);s[0]=y;var a={};for(var c in r)hasOwnProperty.call(r,c)&&(a[c]=r[c]);a.originalType=e,a[p]="string"==typeof e?e:i,s[1]=a;for(var l=2;l<o;l++)s[l]=t[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}y.displayName="MDXCreateElement"}}]);